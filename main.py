"""
API REST para notificaciones de trazabilidad - R√°pido Ochoa
Sistema inteligente de seguimiento con verificaciones optimizadas
"""

from fastapi import FastAPI, HTTPException, BackgroundTasks
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import Optional, List
from datetime import datetime, timedelta
import logging
import os

from database import SessionLocal, init_db, Suscripcion, HistorialVerificacion
from config import TIEMPOS_VIAJE, CIUDADES_NORMALIZE
from utils import consultar_guia_rastreo, enviar_push_notification, calcular_proxima_verificacion

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = FastAPI(
    title="API Notificaciones R√°pido Ochoa",
    description="Sistema inteligente de notificaciones push para trazabilidad",
    version="1.0.0"
)

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Modelos de Request/Response
class SuscripcionCreate(BaseModel):
    numero_guia: str
    token_fcm: str
    telefono: Optional[str] = None

class SuscripcionResponse(BaseModel):
    id: int
    numero_guia: str
    estado_actual: Optional[str]
    origen: Optional[str]
    destino: Optional[str]
    fecha_creacion: datetime
    activo: bool
    proxima_verificacion: Optional[datetime]

class EstadisticasResponse(BaseModel):
    total_suscripciones: int
    activas: int
    completadas: int
    verificaciones_pendientes: int

# Inicializar BD al arrancar
@app.on_event("startup")
async def startup_event():
    logger.info("üöÄ Iniciando API de Notificaciones...")
    init_db()
    logger.info("‚úÖ Base de datos inicializada")

# ============ ENDPOINTS PRINCIPALES ============

@app.get("/")
def root():
    return {
        "servicio": "API Notificaciones R√°pido Ochoa",
        "version": "1.0.0",
        "descripcion": "Sistema inteligente de notificaciones push",
        "caracteristicas": [
            "Verificaci√≥n optimizada por distancia",
            "PostgreSQL persistente",
            "Firebase Cloud Messaging",
            "Limpieza autom√°tica"
        ],
        "endpoints": {
            "suscribirse": "POST /api/suscribir",
            "estado": "GET /api/suscripcion/{guia}",
            "verificar": "POST /api/verificar (Cron Job)",
            "estadisticas": "GET /api/stats"
        }
    }

@app.post("/api/suscribir", response_model=SuscripcionResponse)
async def suscribir_guia(data: SuscripcionCreate, background_tasks: BackgroundTasks):
    """
    Suscribe un cliente a las notificaciones de una gu√≠a
    
    Body:
    {
        "numero_guia": "E121101188",
        "token_fcm": "token_firebase_del_dispositivo",
        "telefono": "+573001234567" (opcional)
    }
    """
    db = SessionLocal()
    
    try:
        logger.info(f"üì¶ Nueva suscripci√≥n: {data.numero_guia}")
        
        # Verificar si ya existe suscripci√≥n activa
        suscripcion_existente = db.query(Suscripcion).filter(
            Suscripcion.numero_guia == data.numero_guia,
            Suscripcion.token_fcm == data.token_fcm,
            Suscripcion.activo == True
        ).first()
        
        if suscripcion_existente:
            logger.info(f"‚ö†Ô∏è Suscripci√≥n ya existe para {data.numero_guia}")
            return SuscripcionResponse(
                id=suscripcion_existente.id,
                numero_guia=suscripcion_existente.numero_guia,
                estado_actual=suscripcion_existente.estado_actual,
                origen=suscripcion_existente.origen,
                destino=suscripcion_existente.destino,
                fecha_creacion=suscripcion_existente.fecha_creacion,
                activo=suscripcion_existente.activo,
                proxima_verificacion=suscripcion_existente.proxima_verificacion
            )
        
        # Consultar informaci√≥n inicial de la gu√≠a
        logger.info(f"üîç Consultando informaci√≥n inicial de {data.numero_guia}")
        info_guia = consultar_guia_rastreo(data.numero_guia)
        
        if not info_guia:
            raise HTTPException(status_code=404, detail=f"No se encontr√≥ la gu√≠a {data.numero_guia}")
        
        # Crear suscripci√≥n
        nueva_suscripcion = Suscripcion(
            numero_guia=data.numero_guia,
            token_fcm=data.token_fcm,
            telefono=data.telefono,
            origen=info_guia.get('origen'),
            destino=info_guia.get('destino'),
            estado_actual=info_guia.get('estado_actual'),
            fecha_admision=info_guia.get('fecha_admision'),
            remitente=info_guia.get('remitente_nombre'),
            destinatario=info_guia.get('destinatario_nombre')
        )
        
        # Calcular pr√≥xima verificaci√≥n
        proxima = calcular_proxima_verificacion(
            estado_actual=nueva_suscripcion.estado_actual,
            origen=nueva_suscripcion.origen,
            destino=nueva_suscripcion.destino,
            fecha_admision=nueva_suscripcion.fecha_admision
        )
        nueva_suscripcion.proxima_verificacion = proxima
        
        db.add(nueva_suscripcion)
        db.commit()
        db.refresh(nueva_suscripcion)
        
        logger.info(f"‚úÖ Suscripci√≥n creada: ID {nueva_suscripcion.id}")
        logger.info(f"üìÖ Pr√≥xima verificaci√≥n: {proxima}")
        
        # Enviar notificaci√≥n de confirmaci√≥n en background
        background_tasks.add_task(
            enviar_push_notification,
            data.token_fcm,
            "Suscripci√≥n Activada",
            f"Te notificaremos cuando la gu√≠a {data.numero_guia} llegue a RECLAME EN OFICINA"
        )
        
        return SuscripcionResponse(
            id=nueva_suscripcion.id,
            numero_guia=nueva_suscripcion.numero_guia,
            estado_actual=nueva_suscripcion.estado_actual,
            origen=nueva_suscripcion.origen,
            destino=nueva_suscripcion.destino,
            fecha_creacion=nueva_suscripcion.fecha_creacion,
            activo=nueva_suscripcion.activo,
            proxima_verificacion=nueva_suscripcion.proxima_verificacion
        )
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"‚ùå Error creando suscripci√≥n: {e}")
        db.rollback()
        raise HTTPException(status_code=500, detail=str(e))
    finally:
        db.close()

@app.get("/api/suscripcion/{numero_guia}", response_model=SuscripcionResponse)
def obtener_estado_suscripcion(numero_guia: str):
    """Consulta el estado actual de una suscripci√≥n"""
    db = SessionLocal()
    
    try:
        suscripcion = db.query(Suscripcion).filter(
            Suscripcion.numero_guia == numero_guia,
            Suscripcion.activo == True
        ).first()
        
        if not suscripcion:
            raise HTTPException(status_code=404, detail="No se encontr√≥ suscripci√≥n activa para esta gu√≠a")
        
        return SuscripcionResponse(
            id=suscripcion.id,
            numero_guia=suscripcion.numero_guia,
            estado_actual=suscripcion.estado_actual,
            origen=suscripcion.origen,
            destino=suscripcion.destino,
            fecha_creacion=suscripcion.fecha_creacion,
            activo=suscripcion.activo,
            proxima_verificacion=suscripcion.proxima_verificacion
        )
        
    finally:
        db.close()

@app.delete("/api/suscripcion/{numero_guia}")
def cancelar_suscripcion(numero_guia: str):
    """Cancela una suscripci√≥n activa"""
    db = SessionLocal()
    
    try:
        suscripcion = db.query(Suscripcion).filter(
            Suscripcion.numero_guia == numero_guia,
            Suscripcion.activo == True
        ).first()
        
        if not suscripcion:
            raise HTTPException(status_code=404, detail="No se encontr√≥ suscripci√≥n activa")
        
        suscripcion.activo = False
        db.commit()
        
        logger.info(f"üóëÔ∏è Suscripci√≥n cancelada: {numero_guia}")
        
        return {"mensaje": "Suscripci√≥n cancelada exitosamente"}
        
    finally:
        db.close()

# ============ ENDPOINT PARA CRON JOB ============

@app.post("/api/verificar")
async def verificar_guias(background_tasks: BackgroundTasks):
    """
    Endpoint ejecutado por Render Cron Job cada 2 horas
    Verifica las gu√≠as que requieren actualizaci√≥n
    """
    db = SessionLocal()
    
    try:
        ahora = datetime.now()
        logger.info(f"‚è∞ Iniciando verificaci√≥n de gu√≠as: {ahora}")
        
        # Obtener suscripciones que necesitan verificaci√≥n
        suscripciones = db.query(Suscripcion).filter(
            Suscripcion.activo == True,
            Suscripcion.proxima_verificacion <= ahora
        ).all()
        
        logger.info(f"üìã Gu√≠as a verificar: {len(suscripciones)}")
        
        verificadas = 0
        notificaciones_enviadas = 0
        
        for suscripcion in suscripciones:
            try:
                # Consultar estado actual
                info_guia = consultar_guia_rastreo(suscripcion.numero_guia)
                
                if not info_guia:
                    logger.warning(f"‚ö†Ô∏è No se pudo consultar gu√≠a {suscripcion.numero_guia}")
                    continue
                
                estado_anterior = suscripcion.estado_actual
                estado_nuevo = info_guia.get('estado_actual')
                
                # Registrar verificaci√≥n
                historial = HistorialVerificacion(
                    suscripcion_id=suscripcion.id,
                    estado_encontrado=estado_nuevo
                )
                db.add(historial)
                
                # Actualizar estado
                suscripcion.estado_actual = estado_nuevo
                suscripcion.ultima_verificacion = ahora
                
                # ¬øLleg√≥ a RECLAME EN OFICINA?
                if "RECLAME EN OFICINA" in estado_nuevo.upper():
                    logger.info(f"üéØ ¬°Gu√≠a {suscripcion.numero_guia} lleg√≥ a destino!")
                    
                    # Enviar notificaci√≥n
                    background_tasks.add_task(
                        enviar_push_notification,
                        suscripcion.token_fcm,
                        "¬°Tu encomienda lleg√≥! üì¶",
                        f"La gu√≠a {suscripcion.numero_guia} est√° lista para recoger en oficina"
                    )
                    
                    # Marcar para limpieza (se borrar√° en 48h)
                    suscripcion.fecha_entrega = ahora
                    suscripcion.proxima_verificacion = None
                    notificaciones_enviadas += 1
                    
                else:
                    # Calcular pr√≥xima verificaci√≥n
                    proxima = calcular_proxima_verificacion(
                        estado_actual=estado_nuevo,
                        origen=suscripcion.origen,
                        destino=suscripcion.destino,
                        fecha_admision=suscripcion.fecha_admision,
                        verificaciones_realizadas=suscripcion.verificaciones_realizadas + 1
                    )
                    suscripcion.proxima_verificacion = proxima
                
                suscripcion.verificaciones_realizadas += 1
                verificadas += 1
                
            except Exception as e:
                logger.error(f"‚ùå Error verificando {suscripcion.numero_guia}: {e}")
                continue
        
        db.commit()
        
        # Limpieza: eliminar suscripciones entregadas hace m√°s de 48h
        limite_limpieza = ahora - timedelta(hours=48)
        eliminadas = db.query(Suscripcion).filter(
            Suscripcion.fecha_entrega != None,
            Suscripcion.fecha_entrega < limite_limpieza
        ).delete()
        
        db.commit()
        
        logger.info(f"‚úÖ Verificaci√≥n completada:")
        logger.info(f"   - Verificadas: {verificadas}")
        logger.info(f"   - Notificaciones enviadas: {notificaciones_enviadas}")
        logger.info(f"   - Registros eliminados: {eliminadas}")
        
        return {
            "timestamp": ahora.isoformat(),
            "guias_verificadas": verificadas,
            "notificaciones_enviadas": notificaciones_enviadas,
            "registros_eliminados": eliminadas
        }
        
    except Exception as e:
        logger.error(f"‚ùå Error en verificaci√≥n: {e}")
        db.rollback()
        raise HTTPException(status_code=500, detail=str(e))
    finally:
        db.close()

# ============ ENDPOINTS DE ADMINISTRACI√ìN ============

@app.get("/api/stats", response_model=EstadisticasResponse)
def obtener_estadisticas():
    """Estad√≠sticas del sistema"""
    db = SessionLocal()
    
    try:
        total = db.query(Suscripcion).count()
        activas = db.query(Suscripcion).filter(Suscripcion.activo == True).count()
        completadas = db.query(Suscripcion).filter(Suscripcion.fecha_entrega != None).count()
        
        ahora = datetime.now()
        pendientes = db.query(Suscripcion).filter(
            Suscripcion.activo == True,
            Suscripcion.proxima_verificacion <= ahora
        ).count()
        
        return EstadisticasResponse(
            total_suscripciones=total,
            activas=activas,
            completadas=completadas,
            verificaciones_pendientes=pendientes
        )
        
    finally:
        db.close()

@app.get("/api/health")
def health_check():
    """Health check para Render"""
    return {
        "status": "ok",
        "timestamp": datetime.now().isoformat(),
        "version": "1.0.0",
        "database": "postgresql"
    }

if __name__ == "__main__":
    import uvicorn
    port = int(os.environ.get("PORT", 8000))
    uvicorn.run("main:app", host="0.0.0.0", port=port, reload=False)